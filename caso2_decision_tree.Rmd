---
title: "title"
author: "author"
output:
  html_document:
    df_print: paged
    highlight: kate
    theme:
      version: 4
      code_font: 
        google: JetBrains Mono
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---
# init 

```{r}
library(tidyverse)
library(tidymodels)
library(corrr)
theme_set(theme_classic())
```

Al cargar los datos especificamos el separador de celdas y de decimales, para parsear correctamente el archivo.

```{r}
churn <- read_delim("churn.csv",
  delim = ";",
  locale = locale(decimal_mark = ",")
) %>%
  janitor::clean_names()
```

# miramos variables

Primero calculamos un resumen general. Vemos que no tenemos datos missing. Dentro de las
numericas, el area_code no es realmente numerica. Por lo cual la cambiamos a factor.
Ademas, arreglamos la variable churn, que es un string feo. 

```{r}
churn %>% 
  mutate(area_code = factor(area_code),
         churn = str_detect(churn, fixed("true", ignore_case = T)),
         state = factor(state)) -> churn

churn %>% skimr::skim()
```

## correlaciones

Miramos correlaciones de las variables numericas mediante un correlograma. En la diagonal
tenemos correlacion perfecta, obviamente, pero ademas hay un par de variables altamente correlacionadas:
los cargos con la cantidad de minutos. Esto es esperable, ya que el cargo es proporcional a la cantidad 
de minutos (escalando por el precio del minuto segun la categoria, dia/tarde/noche/internacional). Eliminamos las variables de cargos, arbitrariamente.

Con respecto a las otras, no hay correlaciones (nótese todo el correlograma en blanco = 0)

```{r}
churn %>%
  select(where(is.numeric)) %>% 
  # seteamos la diagonal a 1 para evitar artefactos
  correlate(diagonal = 1) %>% 
  rearrange() %>% 
  shave() %>% 
  rplot() + theme(axis.text.x = element_text(angle = 45, hjust = 1))

churn %>% select(-ends_with("charge")) -> churn
```

## distribuciones

Para mirar las distribuciones tenemos que mover un poco la tabla. Para eso pivoteamos.
No parece haber cosas extrañas. La mayoria de las variables son aproximadamente normales,
salvo algunas (cust_serv_calls, intl_calls) que son asimetricas positivas, y vmail_message, que
es bimodal (en particular, la gran mayoria de los valores es cero)

```{r}
churn %>%
  select(where(is.numeric)) %>%
  pivot_longer(cols = everything(), names_to = "var", values_to = "value") %>%
  ggplot(aes(value)) +
  geom_histogram(alpha = 0.3, bins = 20) +
  facet_wrap(~var, scales = "free")
```

Mirando con mas detalle vmail_message, eliminando las observaciones 0, vemos que
tiene forma acampanada.

```{r}
churn %>% 
  filter(vmail_message != 0) %>% 
  ggplot(aes(vmail_message)) + geom_histogram(alpha = 0.3, binwidth = 1)
```

Para corroborar, podemos hacer qqplots. Corroboramos que todas las variables, salvo
cust_serv_calls e intl_calls son aproximadamente normales. 

```{r}
churn %>%
  select(where(is.numeric)) %>%
  pivot_longer(cols = everything(), names_to = "var", values_to = "value") %>%
  filter(!(var == "vmail_message" & value == 0)) %>% 
  ggplot(aes(sample = value)) + 
  geom_qq(size = .1) + geom_qq_line() + facet_wrap(~var, scales = "free")
```

Por ultimo, podemos separar (coloreando) las distribuciones de las numericas por churn,
para ver si hay asociaciones. Vemos que la mayoria de las distribuciones son similares, salvo
day_mins. Parece que hay una subpoblacion de churners que hablan mas cantidad de minutos durante el dia.

Con respecto a cust_serv_calls, dado que es una variable discreta (y con muy baja cardinalidad) la
estimacion de la distribución es artefactual.

```{r}
churn %>%
  select(where(is.numeric), churn) %>%
  pivot_longer(cols = -churn, names_to = "var", values_to = "value") %>% 
  ggplot(aes(value, color = churn, fill = churn)) +
  geom_density(alpha = 0.3) +
  #geom_histogram(alpha = 0.3) +
  facet_wrap(~var, scales = "free")
```


```{r}
churn %>%
  select(where(is.numeric), churn) %>%
  pivot_longer(cols = -churn, names_to = "var", values_to = "value") %>% 
  ggplot(aes(churn, value, color = churn)) +
  geom_boxplot()+
  facet_wrap(~var, scales = "free")
```


## categoricas

Graficamos las proporciones de churn en los niveles de las diferentes variables categoricas.
Vemos que no hay asociacion con respecto al area_code. Por otro lado, los clientes con intl_plan son
mas propensos a churnear. Por ultimo, con respecto a vmail_plan, los clientes sin vmail_plan tienden a churnear un poco mas, pero la diferencia es pequeña. 

```{r}
churn %>% 
  select(area_code, intl_plan, vmail_plan, churn) %>% 
  pivot_longer(cols = -churn, names_to = "var", values_to = "level") %>%
  count(var, level, churn) %>% 
  group_by(var, level) %>% 
  mutate(total_per_level = sum(n),
         prop_churn = n / total_per_level) %>% 
  
  ggplot(aes(level, prop_churn, fill = churn)) +
  geom_col() +
  facet_wrap(~var, scales = "free_x")
  
```

Con respecto al estado de residencia, lo miramos independientemente, ya que posee
alta cardinalidad y se ensucian las figuras. Graficando la proporcion de churn por estado
vemos que hay diferencias entre estados. Podemos explorar por region graficando un mapa!

```{r}
churn %>% 
  count(state, churn) %>% 
  group_by(state) %>% 
  mutate(total_per_state = sum(n),
         prop_churn = n / total_per_state,
         # creo columna para ordenar (necesito 1 elemento por nivel!)
         order = prop_churn[churn == TRUE]) %>% ungroup() -> churn_state

churn_state %>% 
  # reordeno state via la columna de orden
  ggplot(aes(x = fct_reorder(state, order), y = prop_churn, fill = churn)) +
  geom_col()
```

No vemos una asociacion regional muy marcada con respecto a la probabilidad de churn.
Quiza en la costa oeste y noreste la probabilidad es un poco mayor. Mientras que 
el interior del pais tiende a ser mas oscuro. Pero hay excepciones.

Vale aclarar que no nos especializamos (aun) en analisis geografico (ni mucho menos),
por lo que desconocemos las potenciales sutilezas en la representación e interpretación. 
Pero nos pareció un lindo experimento.

```{r}

# cargo tabla para graficar mapa
us <- map_data("state")

# necesito los codigos de dos letras de los estados
state_code <- tibble(state = state.abb,
                     state_name = tolower(state.name))
# junto los codigos en la tabla del mapa
us %>%
  left_join(state_code, by = c("region" = "state_name")) -> us

# defino un theme lindo para el mapa, sacando todas las lineas y textos
theme_mapa <- theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_blank(),
    axis.title = element_blank()
  )

churn_state %>%
  select(state, churn, prop_churn) %>% 
  pivot_wider(names_from = churn, values_from = prop_churn, names_prefix = "churn_") %>% 
  #mutate(log_odds = log(churn_TRUE / churn_FALSE)) %>% 
  right_join(us, by = "state") %>% 
  
  ggplot(aes(fill = churn_TRUE)) + 
  # importante el group para que las lineas del mapa queden unidas por estado
  geom_polygon(aes(long, lat, group = group), color = "black") +
  scale_fill_viridis_c() +
  coord_map() + 
  
  ggtitle("probabilidad de churn por estado") +
  theme_mapa
```

